---
title: 'How-to: Нумерация'
---

Предположим есть некоторый набор книг. Для каждой из них определяется номер как целое число.

import {CodeSample} from './CodeSample.mdx'

<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=UseCaseNumerating&block=numbermaster"/>

Реализуем свойство, которое будет по номеру находить книгу. Оно может быть полезно, например, при импорте данных, в котором книга идентифицируется своим номером. При помощи него можно получать ссылку на объект книги, получив параметром ее номер.

<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=UseCaseNumerating&block=numberaggr"/>

Оператор [GROUP AGGR](Grouping_GROUP_.md) автоматически добавляет ограничение на уникальность номера. При попытки записать в базу данных повторный номер будет выдано сообщение об ошибке.

Добавляем [событие](Events.md), которое будет автоматически проставлять книге номер, равный следующий за максимальным из существующих в базе данных.

<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=UseCaseNumerating&block=numbergenerate"/>

Событие будет вызвано в момент сохранения создания книги в базу данных в той же транзакции.

В некоторых ситуациях существует необходимость делать разную нумерацию для одного и того же объекта. Для этой цели можно добавить специальный класс **Numerator**.

<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=UseCaseNumerating&block=numerator"/>

В свойстве **value** будет храниться текущее значение нумератора, которое будет записываться в номер нужного объекта. Чтобы достичь этого, для объекта (например, заказ) задается ссылка на соответствующей нумератор. В момент создания объекта, если она задана, то нужно автоматически проставить номеру заказа текущее значение нумератора и увеличить его на один.

<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=UseCaseNumerating&block=numeratororder"/>

В условии события проверяется на то, что номер не был изменен, чтобы не изменять его, если пользователь вручную задал номер (или он проставился при импорте).

Важным отличием работы через нумератор от "проставления максимального значения плюс один" является обработка одновременного добавления объектов. Во втором случае, если два пользователя одновременно создадут объекты, то последнему в момент сохранения будет выдано сообщение о повторении номера, и он будет вынужден вручную сохранить повторно. Изменения, сделанные во всех событиях таким образом, будут "откачены", и повторное сохранение сгенерирует новый номер. В случае с нумератором, транзакция последнего пользователя получит CONFLICT UPDATE на поле **value** для нумератора (так как обе транзакции меняют поле одной строки в базе данных). Дальше система автоматически откатит транзакцию и все изменения, сделанные в событии, и начнет ее проводить повторно без вмешательства пользователя. Таким образом пользователь заметит лишь возможно в два раза медленнее сохранение, но никаких его дополнительных действий не потребуется.

Для того, чтобы пользователю не приходилось постоянно выбирать нумератор для заказа, можно ввести свойство без входов, которое будет указывать на нумератор по умолчанию. После этого добавить событие, которое будет автоматически проставлять нумератор, в случае если пользователь не выбрал его вручную.

<CodeSample url="https://ru-documentation.lsfusion.org/sample?file=UseCaseNumerating&block=numeratororderdefault"/>
